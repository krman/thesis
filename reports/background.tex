\chapter{Background}
\label{ch:background}

\section{Software-Defined Networking}
Software-defined networking is a set of philosophies and concepts on how networking should be done. Crucially, networking should be programmable. The core idea is separation of the control and data planes; specifically, separation in a way that is standards-compliant and vendor-independent \cite{onf:sdn}. Although the movement is not intrinsically tied to any specific technologies, the OpenFlow protocol \cite{onf:switch140}, which is used to communicate between the control and data planes, is quite strongly linked to it.

McKeown describes the networking industry as vertically integrated and proprietary, with little innovation \cite{mckeown:sdn}, comparing this to the state of computing prior to the adoption of high-level operating systems using standard instruction sets to communicate with the hardware. Similarly, the control plane in SDN can be seen as a network operating system, with OpenFlow as the instruction set for communicating with switches. This echoes the development towards greater abstraction evidenced by the move towards flow- over packet-based networking and the rise of quality-of-service considerations. Such requirements can be difficult to meet without some control over switch forwarding tables.

\begin{figure}
  \centering
  \includegraphics[scale=0.8]{../images/sdnclear.pdf}
  \caption{Centralisation of control in software defined networks}
  Each switch maintains an out-of-band connection to a controller, which instructs switches to update their forwarding tables via the OpenFlow protocol.
  \label{fig:sdn}
\end{figure}

OpenFlow was originally conceived \cite{mckeown:openflow} as a research tool to enable academics to test new protocols easily and receive rapid feedback, while allowing vendors to continue to protect the inner workings of their switches. More recently \cite{onf:sdn} the focus has shifted to large datacenters and commercial networks with complex routing requirements. In \cite{mckeown:sdn}, McKeown refers to the  ``ossified network'': due to the black-box nature of modern network components such as switches and routers, experimentation is not encouraged and researchers and network administrators must stick to standard protocols until new ones are supported by vendors. This process can take a long time and the feedback cycle is slow. In contrast, SDN offers the ability to easily implement new protocols on real networks, and programmatically and automatically test and monitor many more aspects of the system.

Software-defined networks rely on two concepts: flow-based routing and the existence of a central controller. Flow-based routing means routing based on flows (linked series of related packets such as all TCP traffic, all traffic from one MAC address or to a particular IP subnet). This concept was reasonably well-developed \cite{wellons:oblivious,wang:routing} before SDN.

The other element of SDN is the existence of a central network OS which can communicate with all nodes. This raises the obvious objection that in a mesh network centralisation is not ideal; however, this is not centralised routing where all packets must pass through the controller. \cite{handigol:asterix} makes the distinction between ``logically centralised'' and ``distributed through the network''. Once rules are installed packet forwarding happens at individual switches as usual. The controller can push an initial set of rules as soon as a switch connects to it if desired. Later, when the first packet of a new kind of flow arrives at a switch, it encapsulates the packet and sends it to the controller. The controller then installs the appropriate rules on the appropriate switches \cite{mckeown:sdn}. Depending on configuration (fail standalone mode or fail secure mode) these rules can remain in place if the controller connection is lost, or the switch can drop all packets \cite{onf:switch140}.

Dely et al \cite{dely:wmn} implemented an SDN controller and tested it on KAUMesh using the metrics of forwarding performance, amount of control traffic and rule activation time (time between the first packet of a new flow arriving, and that packet being forwarded onwards). They found that while SDN drastically increased ease of development (the problem of node mobility was solved in a few lines of code), the SDN controller performed slightly worse on their network than existing algorithms such as OLSR. The performance was within acceptable limits for their small-scale test, but they noted that scalability could be an issue when deploying on larger networks.

what about traditional routing. not specific to meshes, but related to multipath stuff? eg equal-cost multipath forwarding (ECMP) (reference? see alfares). uses hash of packet headers to choose a path arbitrarily, but such that all the packets go down that path for related flows (as dlg explained) \cite{alfares:hedera}. should also mention lots of things being variations on shortest-path, since i use it as a metric in other things.

\section{Multicommodity Flow Problems}
\label{sec:mcf}
One approach mentioned in \cite{wellons:augmenting} and \cite{dai:dynamic} is to model flow-based networking as a multi-commodity network flow problem \cite[pp. 862--863]{cormen:algorithms}. Flows are modelled as commodities moving between various source and sink nodes in the network. This is an optimisation problem where the objective function can be adjusted depending on the desired outcomes, such as maximising overall throughput or maximising worst-case performance. The authors of \cite{wellons:augmenting} note that such approaches can be sensitive to accurate predictions of demand, but had success merging it with more dynamic heuristic algorithms. 

actually we really care about the unsplittable flow problem, studied by a bunch of people. tcp imposes two significant restrictions:

\begin{enumerate}
    \item everything goes to shit if you send things down multiple paths
    \item tcp slows down its sending rate if you lose packets, so demand changes
\end{enumerate}


need to talk about maths here. haven't put any of those papers into my stupid bib file. something about unsplittable flows. wait yes i have \cite{anag:mazing, bonsma:ufp, chakrabarti:ufp}. basically that smart people have done maths things to solve the unsplittable flow problem, or at least to model it in various different ways, \cite{walkowiak:residual} made it into a linear program to be solved with a generic solver, others did other things...

hedera was amazing and is better than this in every conceivable way \cite{alfares:hedera}. they didn't use linear programming, they used a couple of different approaches, simulated annealing i think was the most efficient iirc. still, solving the same fundamental problem.

should probably talk about fat-trees too, well clos networks or something \cite{alfares:fattree}. or something about why i'm using methods something something

\section{Linear Programming}

is a good thing i should mention.

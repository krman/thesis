\chapter{Methodology}

The goal of this thesis is to implement a controller to do optimal routing in a mesh network, with comparable or better performance than existing solutions available, assuming that the controller has topology and link capacity information and a route to each switch in the network. The problem can be initially modelled as a multi-commodity flow problem and solved using standard optimisation techniques.

In order to assess the performance of the controller, a set of meaningful network tests will be devised and the controller's performance benchmarked against that of a selection of existing techniques for software-defined networking in wireless mesh networks.

The project can be divided into a number of steps:

\begin{enumerate}
\item Compile an overview of common approaches, and select a representative sample which can be experimentally reproduced; implement a working version of each selected approach
\item Mathematically model the proposed new controller; implement it in POX
\item Explicitly define the performance objectives and benchmarking metrics; design a set of topologies to capture performance differences between approaches; outline a range of network events to simulate in Mininet 
\item Conduct benchmarking of existing approaches and new controller; note relative performance on various metrics, and improve controller based on benchmarking results
\end{enumerate}

\section{Experiment Design}
A suitable control still needs to be used. Depending on the specific experiment (ie at what level you want to compare) a different one could be chosen. For these purposes the following are available:

\begin{itemize}
\item Plain mininet with switches running traditional routing algorithms (whatever these are)
\item POX's \texttt{forwarding.l2\_learning} controller
\item Shortest-path routing objective function (not PuLP/LP, but still uses rest of framework)
\end{itemize}


This chapter outlines in more detail the process of conducting these benchmarks and gathering data and stuff.

\section{Simulation API}
In order to properly measure certain parts of the system individually and guarantee that results are due to one specific section you need to inject mock data at certain parts of the system.

The system lets you specify callbacks to be used in the following places.

\begin{itemize}
\item fake flows
\item forwarding rules
\item objective function
\item fake topology
\end{itemize}

\section{Experiment Scripts}
This should actually be content taken roughly from the "writing experiment scripts" chapters of the documentation, and the section which talks about individual things, what's the word, injecting mock data.

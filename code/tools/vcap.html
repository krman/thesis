<!DOCTYPE html>

<head>
	<title>pcap visualiser</title>
	<meta http-equiv="X-UA-Compatible" content="IE=edge" />
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<!--<script type="text/javascript" src="http://d3js.org/d3.v3.min.js"></script>-->
	<script type="text/javascript" src="d3.v3.min.js"></script>
	<style>
		.files {
			padding: 10px;
			border: 1px solid #ccc;
			background: #eee;
		}
		#sidebar {
			float: left;
			width: 200px;
		}
		.packet {
			padding: 10px;
			border-width: 0 1px 1px 1px;
			border-style: solid;
			border-color: #ccc;
		}
		.packet.current {
			background: #eee;
		}
		#controls {
			float: right;
		}
		#reset, #step, #play {
			border: 1px solid #ccc;
			background: #ddd;
		}
		#display {
			padding: 50px;
			text-align: center;
		}

		.node {
			stroke: #fff;
			stroke-width: 1.5px;
		}
		.link {
			stroke: #999;
			stroke-opacity: .6;
		}
	</style>
</head>

<body>
	<div class="files">
		vcap | <input type="file" id="pcap">
	</div>

	<div id="sidebar">
		<div></div>
	</div>

	<div id="controls">
		<button id="reset">reset</button>
		<button id="step">step</button>
		<button id="play">play</button>
	</div>
	<div id="display"></div>

	<script type="text/javascript" language="javascript">
		function parse_pcap(pcap) {
			buffer = new Uint8Array(pcap);
			header = new DataView(pcap,0,24);
			packets = new DataView(pcap,24);

			var le, magic = header.getUint32(0);
			switch(magic) {
				case 0xa1b2c3d4:
					le = 0; break;
				case 0xd4c3b2a1:
					le = 1; break;
				case 0xa1b23c4d:
				case 0x4d3cb2a1:
					console.log("no support for nanosecond resolution pcaps"); break;
				default:
					console.log("bad magic number"); break;
			}
			
			var data_link = header.getUint32(20,le);
			if (data_link != 113) {
				console.log("bad link-layer header type (not LINUX_SLL)");
			}

			packet = 0, i = 0, next = 0;
			var ts_sec, ts_usec, incl_len, orig_len; // pcap
			var packet_type, arphrd, ll_addr_len, ll_addr, protocol; // linux_sll
			var tos, ip_len, src_addr = new Array(4), dst_addr = new Array(4); // ipv4
				
				/*
			ofp_type = {
				0:{name:"Hello", func:parse_hello},
				1:{name:"Error", func:parse_error},
				2:{name:"Echo-Request", func:parse_echo_request},
				3:{name:"Echo-Reply", func:parse_echo_reply},
				4:{name:"Experimenter", func:parse_experimenter},
				5:{name:"Features-Request", func:parse_features_request},
				6:{name:"Features-Reply", func:parse_features_reply},
				7:{name:"Get-Config-Request", func:parse_get_config_request},
				8:{name:"Get-Config-Reply", func:parse_get_config_reply},
				9:{name:"Set-Config", func:parse_set_config},
				10:{name:"Packet-In", func:parse_packet_in},
				11:{name:"Flow-Removed", func:parse_flow_removed},
				12:{name:"Port-Status", func:parse_port_status},
				13:{name:"Packet-Out", func:parse_packet_out},
				14:{name:"Flow-Mod", func:parse_flow_mod},
				15:{name:"Group-Mod", func:parse_group_mod},
				16:{name:"Port-Mod", func:parse_port_mod},
				17:{name:"Table-Mod", func:parse_table_mod},
				18:{name:"Multipart-Request", func:parse_multipart_request},
				19:{name:"Multipart-Reply", func:parse_multipart_reply},
				20:{name:"Barrier-Request", func:parse_barrier_request},
				21:{name:"Barrier-Reply", func:parse_barrier_reply},
				24:{name:"Role-Request", func:parse_role_request},
				25:{name:"Role-Reply", func:parse_role_reply},
				26:{name:"Get-Async-Request", func:parse_get_async_request},
				27:{name:"Get-Async-Reply", func:parse_get_async_reply},
				28:{name:"Set-Async", func:parse_set_async},
				29:{name:"Meter-Mod", func:parse_meter_mod},
				30:{name:"Role-Status", func:parse_role_status},
				31:{name:"Table-Status", func:parse_table_status},
				32:{name:"Requestforward", func:parse_requestforward},
				33:{name:"Bundle-Control", func:parse_bundle_control},
				34:{name:"Bundle-Add-Message", func:parse_bundle_add_message}
			};
			*/


			ofp_type = {
				0:{name:"Hello", func:parse_hello},
				1:{name:"Error", func:parse_hello},
				2:{name:"Echo-Request", func:parse_hello},
				3:{name:"Echo-Reply", func:parse_hello},
				4:{name:"Experimenter", func:parse_hello},
				5:{name:"Features-Request", func:parse_hello},
				6:{name:"Features-Reply", func:parse_hello},
				7:{name:"Get-Config-Request", func:parse_hello},
				8:{name:"Get-Config-Reply", func:parse_hello},
				9:{name:"Set-Config", func:parse_hello},
				10:{name:"Packet-In", func:parse_hello},
				11:{name:"Flow-Removed", func:parse_hello},
				12:{name:"Port-Status", func:parse_hello},
				13:{name:"Packet-Out", func:parse_hello},
				14:{name:"Flow-Mod", func:parse_hello},
				15:{name:"Group-Mod", func:parse_hello},
				16:{name:"Port-Mod", func:parse_hello},
				17:{name:"Table-Mod", func:parse_hello},
				18:{name:"Multipart-Request", func:parse_hello},
				19:{name:"Multipart-Reply", func:parse_hello},
				20:{name:"Barrier-Request", func:parse_hello},
				21:{name:"Barrier-Reply", func:parse_hello},
				24:{name:"Role-Request", func:parse_hello},
				25:{name:"Role-Reply", func:parse_hello},
				26:{name:"Get-Async-Request", func:parse_hello},
				27:{name:"Get-Async-Reply", func:parse_hello},
				28:{name:"Set-Async", func:parse_hello},
				29:{name:"Meter-Mod", func:parse_hello},
				30:{name:"Role-Status", func:parse_hello},
				31:{name:"Table-Status", func:parse_hello},
				32:{name:"Requestforward", func:parse_hello},
				33:{name:"Bundle-Control", func:parse_hello},
				34:{name:"Bundle-Add-Message", func:parse_hello}
			};

			while (i < buffer.length-24) {
				changelog[packet] = new Object();
				changelog[packet].added = [];
				changelog[packet].removed = [];

				// pcap packet header: host byte order
			  ts_sec = packets.getUint32(i,le).toString();
			  ts_usec = packets.getUint32(i+4,le).toString();
				timestamp = new Date(parseInt(parseFloat(ts_sec + "." + ts_usec)*1000));
				i += 8;

			  incl_len = packets.getUint32(i,le);
				i += 4;

			  orig_len = packets.getUint32(i,le);
				i += 4;

				next = i + incl_len;

				// linux_sll header: network byte order
			  packet_type = packets.getUint16(i); // multicast, broadcast, unicast etc
				i += 2+2+2+8; // skip arphrd, ll-addr-len & ll-addr

				protocol = packets.getUint16(i);
				if (protocol != 0x0800) {
					i = next; continue;
				}
				i += 2;

				// ipv4 header
				i += 9; // skip version, ihl, tos, length, id, flags, offset, ttl

				protocol = packets.getUint8(i);
				if (protocol != 6) {
					i = next; continue;
				}
				i += 1;
				
				i += 2; // skip header checksum

				src_addr[3] = packets.getUint8(i); i += 1;
				src_addr[2] = packets.getUint8(i); i += 1;
				src_addr[1] = packets.getUint8(i); i += 1;
				src_addr[0] = packets.getUint8(i); i += 1;

				dst_addr[3] = packets.getUint8(i); i += 1;
				dst_addr[2] = packets.getUint8(i); i += 1;
				dst_addr[1] = packets.getUint8(i); i += 1;
				dst_addr[0] = packets.getUint8(i); i += 1;

				// tcp header
				tcp_start = i;
				src_port = packets.getUint16(i); i += 2;
				dst_port = packets.getUint16(i); i += 2;

				i += 8; // skip seq/ack numbers

				tcp_offset = packets.getUint8(i) / 16; i += 1;
				
				i = tcp_start + tcp_offset*4; // skip rest of tcp header

				if (i >= next) {
					i = next; continue;
				}

				// openflow header
				of_version = packets.getUint8(i); i += 1;
				of_type = packets.getUint8(i); i += 1;
				of_len = packets.getUint16(i); i += 2;
				of_xid = packets.getUint32(i); i += 4;

				console.log("new packet: "+ofp_type[of_type].name);

/*
				// this should be nowhere near this part of the code
				if (of_type === 0) {
				}
*/
				add_packet(ofp_type[of_type], new DataView(pcap, i, next-i));
				
				i = next;
				packet += 1;
			}
			console.log("stoping");
		}

		/* -------------------------------- *\
		** objects and changelogs and stuff **
		\* -------------------------------- */

		components = [];
		changelog = [];
		switchcount = 0;
		displayed = [];

		// add switch on hello message
		function add_switch(port) {
			s = new Object();
			switchcount += 1;
			s.label = "s"+switchcount;
			s.type = "switch";
			id = components.push(s) - 1;
			return id;
		}

		// display current items appropriate for this stage
		function update_components(start, end) {
			diff_between(start, end);
		}

		function add_to_display(e) {
			console.log("from packet "+i+" add "+e);
			displayed.push(e);
		}

		function remove_from_display(e) {
			console.log("from packet "+i+" remove "+e);
			console.log(displayed);
			console.log(e);
			console.log(displayed.indexOf(e));
			index = displayed.indexOf(e);
			if (index > -1) {
				displayed.splice(index, 1);
			}
		}

		// components added/deleted from one packet to another
		function diff_between(from, to) {
			console.log("changelog");
			console.log(changelog);
			diff = to - from;
			if (diff > 0) {
				for (i=from+1; i<to+1; i++) {
					changelog[i].added.forEach(add_to_display);
					changelog[i].removed.forEach(remove_from_display);
				}
			} else {
				for (i=from; i>to; i--) {
					changelog[i].added.forEach(remove_from_display);
					changelog[i].removed.forEach(add_to_display);
				}
			}
		}

		/* --------------------------*\
		** parsing openflow contents **
		\* --------------------------*/

		function parse_hello(pkt) {
			console.log("parsing hello");
			// of hello header (need to do the hello elements stuff)
			if (src_port != 6633) {
				id = add_switch(src_port);
				changelog[packet].added = [id];
			}
		}

		/* --------------------------------- *\
		** displaying packets in the sidebar **
		\* --------------------------------- */

		// initial selection of packet file
		function select_file(e) {
			var file = e.target.files[0];

			var reader = new FileReader();
      reader.onload = (function(file) {
        return function(e) { parse_pcap(e.target.result); };
      })(file);
      reader.readAsArrayBuffer(file);
		}

		// packet creation
		function add_packet(type, packet) {
			model.objects.push(type.name);
			var np = document.createElement("div");
			np.classList.add("packet");
			np.innerHTML = type.name;
			type.func(packet);
			np.addEventListener('click', select_packet, false);
			sidebar.firstElementChild.appendChild(np);
		}

		// packet selection
		function get_selected_packet() {
			return document.getElementsByClassName('current')[0];
		}

		function get_index_of_packet(p) {
			return Array.prototype.slice.call(sidebar.firstElementChild.children).indexOf(p);
		}

		function get_selected_packet_index() {
			p = get_selected_packet();
			return get_index_of_packet(p);
		}

		function change_selected_packet(p) {
			if (old = get_selected_packet()) {
				old.classList.remove("current");
			}
			p.classList.add("current");
			index = get_selected_packet_index();
			update_components(get_index_of_packet(old), get_index_of_packet(p));
			//display.innerHTML = p.innerHTML + displayed.toSource() + changelog[index].toSource();
			console.log(components);
			nodes.push({name:4});
			links.push({source:3, target:1});
			update_view();
		}

		function select_packet(e) {
			change_selected_packet(e.target);
		}

		// reset/step/play button callbacks
		function reset_visualisation(e) {
			change_selected_packet(sidebar.firstElementChild.firstElementChild);
		}

		function step_visualisation(e) {
			current = get_selected_packet();
			if (!current) {
				reset_visualisation();
			}
			if (next = current.nextElementSibling) {
				change_selected_packet(next);
			}
		}

		// reusable chart!
		function networkGraph() {
			var width = 960,
					height = 500,
					color = d3.scale.category20();

			svg = d3.select("#display").append("svg")
					.attr("width", width)
					.attr("height", height);

			nodes = [{name:1}, {name:2}, {name:3}];
			links = [{source:1,target:2}, {source:2,target:0}];

			force = d3.layout.force()
					.charge(-500)
					.linkDistance(100)
					.size([width, height])
					.nodes(nodes)
					.links(links);

			function my(selection, elements) {
				selection.each(function(d, i) {

					link = svg.selectAll(".link")
							.data(force.links());

					link.exit().remove();

					link.enter()
							.append("line")
							.attr("class", "link")
							.style("stroke-width", function(d) { return 1; });

					node = svg.selectAll(".node")
							.data(force.nodes());
					
					node.exit().remove();

					node.enter()
							.append("circle")
							.attr("class", "node")
							.attr("r", 10)
							.style("fill", function(d) { if (d.name == 4) { return "red"; } return color(d); })
							.call(force.drag);

					force.on("tick", function() {
						link.attr("x1", function(d) { return d.source.x; })
								.attr("y1", function(d) { return d.source.y; })
								.attr("x2", function(d) { return d.target.x; })
								.attr("y2", function(d) { return d.target.y; });

						node.attr("cx", function(d) { return d.x; })
								.attr("cy", function(d) { return d.y; });
					});

					force.start();
				});
			}

			my.width = function(value) {
				if (!arguments.length) return width;
				width = value;
				return my;
			};

			my.height = function(value) {
				if (!arguments.length) return height;
				height = value;
				return my;
			};

			return my;
		}

		function start_view() {
			update_view();
		}

		function update_view() {
			d3.select("#display").call(update_network_graph, displayed);
		}

		update_network_graph = networkGraph();
		model = {"objects":[], "changes":{}};
		document.getElementById('pcap').addEventListener('change', select_file, false);
		display = document.getElementById('display');
		sidebar = document.getElementById('sidebar');
		packets = document.getElementsByClassName('packet');
		for (var i = 0; i < packets.length; i++) {
			packets[i].addEventListener('click', select_packet, false);
		}
		document.getElementById('reset').addEventListener('click', reset_visualisation, false);
		document.getElementById('step').addEventListener('click', step_visualisation, false);
		start_view();
	</script>
</body>
</html>

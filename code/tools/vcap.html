<!DOCTYPE html>

<head>
	<title>pcap visualiser</title>
	<meta http-equiv="X-UA-Compatible" content="IE=edge" />
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<!--<script type="text/javascript" src="http://d3js.org/d3.v3.min.js"></script>-->
	<script type="text/javascript" src="d3.v3.min.js"></script>
	<style>
		.files {
			padding: 10px;
			border: 1px solid #ccc;
			background: #eee;
		}
		#sidebar {
			float: left;
			width: 200px;
		}
		.packet {
			padding: 10px;
			border-width: 0 1px 1px 1px;
			border-style: solid;
			border-color: #ccc;
		}
		.packet.current {
			background: #eee;
		}
		#controls {
			float: right;
		}
		#reset, #step, #play {
			border: 1px solid #ccc;
			background: #ddd;
		}
		#display {
			padding: 50px;
			text-align: center;
		}
	</style>
</head>

<body>
	<div class="files">
		vcap | <input type="file" id="pcap">
	</div>

	<div id="sidebar">
		<div></div>
	</div>

	<div id="controls">
		<button id="reset">reset</button>
		<button id="step">step</button>
		<button id="play">play</button>
	</div>
	<div id="display"></div>

	<script type="text/javascript" language="javascript">
		function parse_pcap(pcap) {
			buffer = new Uint8Array(pcap);
			header = new DataView(pcap,0,24);
			packets = new DataView(pcap,24);

			var le, magic = header.getUint32(0);
			switch(magic) {
				case 0xa1b2c3d4:
					le = 0; break;
				case 0xd4c3b2a1:
					le = 1; break;
				case 0xa1b23c4d:
				case 0x4d3cb2a1:
					console.log("no support for nanosecond resolution pcaps"); break;
				default:
					console.log("bad magic number"); break;
			}
			
			var data_link = header.getUint32(20,le);
			if (data_link != 113) {
				console.log("bad link-layer header type (not LINUX_SLL)");
			}

			var packet = 0, i = 0, next = 0;
			var ts_sec, ts_usec, incl_len, orig_len; // pcap
			var packet_type, arphrd, ll_addr_len, ll_addr, protocol; // linux_sll
			var tos, ip_len, src_addr = new Array(4), dst_addr = new Array(4); // ipv4
			
			ofp_type = {
				0:"Hello", 
				1:"Error", 
				2:"Echo-Request", 
				3:"Echo-Reply",
				4:"Experimenter",
				5:"Features-Request",
				6:"Features-Reply",
				7:"Get-Config-Request",
				8:"Get-Config-Reply",
				9:"Set-Config",
				10:"Packet-In",
				11:"Flow-Removed",
				12:"Port-Status",
				13:"Packet-Out",
				14:"Flow-Mod",
				15:"Group-Mod",
				16:"Port-Mod",
				17:"Table-Mod",
				18:"Multipart-Request",
				19:"Multipart-Reply",
				20:"Barrier-Request",
				21:"Barrier-Reply",
				24:"Role-Request",
				25:"Role-Reply",
				26:"Get-Async-Request",
				27:"Get-Async-Reply",
				28:"Set-Async",
				29:"Meter-Mod",
				30:"Role-Status",
				31:"Table-Status",
				32:"Requestforward",
				33:"Bundle-Control",
				34:"Bundle-Add-Message"
			};

			while (i < buffer.length-24) {
				changelog[packet] = new Object();

				// pcap packet header: host byte order
			  ts_sec = packets.getUint32(i,le).toString();
			  ts_usec = packets.getUint32(i+4,le).toString();
				timestamp = new Date(parseInt(parseFloat(ts_sec + "." + ts_usec)*1000));
				i += 8;

			  incl_len = packets.getUint32(i,le);
				i += 4;

			  orig_len = packets.getUint32(i,le);
				i += 4;

				next = i + incl_len;

				// linux_sll header: network byte order
			  packet_type = packets.getUint16(i); // multicast, broadcast, unicast etc
				i += 2+2+2+8; // skip arphrd, ll-addr-len & ll-addr

				protocol = packets.getUint16(i);
				if (protocol != 0x0800) {
					i = next; continue;
				}
				i += 2;

				// ipv4 header
				i += 9; // skip version, ihl, tos, length, id, flags, offset, ttl

				protocol = packets.getUint8(i);
				if (protocol != 6) {
					i = next; continue;
				}
				i += 1;
				
				i += 2; // skip header checksum

				src_addr[3] = packets.getUint8(i); i += 1;
				src_addr[2] = packets.getUint8(i); i += 1;
				src_addr[1] = packets.getUint8(i); i += 1;
				src_addr[0] = packets.getUint8(i); i += 1;

				dst_addr[3] = packets.getUint8(i); i += 1;
				dst_addr[2] = packets.getUint8(i); i += 1;
				dst_addr[1] = packets.getUint8(i); i += 1;
				dst_addr[0] = packets.getUint8(i); i += 1;

				// tcp header
				tcp_start = i;
				src_port = packets.getUint16(i); i += 2;
				dst_port = packets.getUint16(i); i += 2;

				i += 8; // skip seq/ack numbers

				tcp_offset = packets.getUint8(i) / 16; i += 1;
				
				i = tcp_start + tcp_offset*4; // skip rest of tcp header

				if (i >= next) {
					i = next; continue;
				}

				// openflow header
				of_version = packets.getUint8(i); i += 1;
				of_type = packets.getUint8(i); i += 1;
				of_len = packets.getUint16(i); i += 2;
				of_xid = packets.getUint32(i); i += 4;

				add_packet(ofp_type[of_type]);

				// this should be nowhere near this part of the code
				if (of_type === 0) {
					console.log("hello?");
					// of hello header (need to do the hello elements stuff)
					if (src_port != 6633) {
						console.log("hello from "+src_port+" packet "+packet);
						id = add_switch(src_port);
						changelog[packet].added = id;
					}
				}

				i = next;
				packet += 1;
			}
		}

		/* ------------------------------------------------------- *\
		** functions dealing with objects and changelogs and stuff **
		\* ------------------------------------------------------- */

		components = [];
		changelog = [];
		switchcount = 0;

		// add switch on hello message
		function add_switch(port) {
			s = new Object();
			switchcount += 1;
			s.label = "s"+switchcount;
			s.type = "switch";
			id = components.push(s) - 1;
			console.log(components);
			return id;
		}

		// initial selection of packet file
		function select_file(e) {
			var file = e.target.files[0];

			var reader = new FileReader();
      reader.onload = (function(file) {
        return function(e) { parse_pcap(e.target.result); };
      })(file);
      reader.readAsArrayBuffer(file);
		}

		// packet creation
		function add_packet(p) {
			model.objects.push(p);
			var np = document.createElement("div");
			np.classList.add("packet");
			np.innerHTML = p;
			np.addEventListener('click', select_packet, false);
			sidebar.firstElementChild.appendChild(np);
		}

		// packet selection
		function get_selected_packet() {
			return document.getElementsByClassName('current')[0];
		}

		function change_selected_packet(p) {
			if (old = get_selected_packet()) {
				old.classList.remove("current");
			}
			p.classList.add("current");
			console.log(p);
			console.log(sidebar);
			index = Array.prototype.slice.call(sidebar.firstElementChild.children).indexOf(p);
			display.innerHTML = p.innerHTML + components.toSource() + changelog[index].toSource();
		}

		function select_packet(e) {
			change_selected_packet(e.target);
		}

		// reset/step/play button callbacks
		function reset_visualisation(e) {
			change_selected_packet(sidebar.firstElementChild.firstElementChild);
		}
		function step_visualisation(e) {
			current = get_selected_packet();
			if (!current) {
				reset_visualisation();
			}
			if (next = current.nextElementSibling) {
				change_selected_packet(next);
			}
		}

		model = {"objects":[], "changes":{}};
		document.getElementById('pcap').addEventListener('change', select_file, false);
		display = document.getElementById('display');
		sidebar = document.getElementById('sidebar');
		packets = document.getElementsByClassName('packet');
		for (var i = 0; i < packets.length; i++) {
			packets[i].addEventListener('click', select_packet, false);
		}
		document.getElementById('reset').addEventListener('click', reset_visualisation, false);
		document.getElementById('step').addEventListener('click', step_visualisation, false);
	</script>
</body>
</html>

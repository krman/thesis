\documentclass[a4paper,12pt]{article}

\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{fullpage}

\usepackage[parfill]{parskip}
\usepackage{amssymb}
\usepackage{alltt}

\newcommand{\degree}{\ensuremath{^\circ}}
\newcommand{\unit}[1]{\ensuremath{\, \mathrm{#1}}}

\begin{document}
\title{Exploring domain independence in grammatical evolution}
\author{Kimberley Manning}
\date{\today}
\newpage

\section*{COMP30290 Natural Computing Project Proposal}

\textbf{Author Name:} Kimberley Manning

\textbf{Author ID:} 12251405

\textbf{Project Title:} Exploring domain independence in grammatical evolution

\subsection*{What is the question that this proposal addresses?}

- this project
--- minimum information the controller needs is
----- sensors (to take in info about the world)
----- actuators (to act on the decisions it makes)
--- for a 2d game this means LRUD and functions to read array
--- PROBLEM: (where the algorithm is given only an array-based map of the game and functions to read from it, and a set of commands to interact with the game) compare a solution using grammatical evolution vs neural networks

Games have long been one of the testing grounds for new artificial intelligence research, and the application of natural computing methods is no exception.  Games, particularly well-studied ones such as Ms. PacMan, present a well-understood problem and an opportunity to compare new methods against the current best approaches on an even playing field.  The best strategies are well-known and it is common to see strategies which are learnt or evolved by each new algorithm compared to these.

A lot of programming effort goes into developing domain-specific terminals* - for example, in Ms. PacMan, functions are provided (hand-coded by the programmer) to calculate distances to ghosts, another one, and yet another example here.  This is even before the often significant amounts of time needed for the learning or evolutionary stage of development.  Despite this, such programs do not generally perform as well as the best hand-crafted ones (cite 1,2,3).  At the end, the programmer is still left with code only suited for one domain. Developing code for a problem that is not as well-understood as Ms. PacMan, still requires a not-insignificant investment by the programmer in order to understand the problem, develop an idea of possible ways of solving the problem, and artificially break this down into helper functions that the natural algorithm can use to generate a solution.

Domain independence was one of Koza's first principles of genetic programming in 1992 (cite 1).  Something similar for neural networks here.  While it is obvious that extremely domain-specific setups* are to be avoided, it is not obvious where the lower limit lies. If not enough information is given, the solution will be useless. Additionally, more effort is needed to evolve complex strategies, given only low-level base code. An immediate problem is that with more generic terminals*/function sets*, the objective function needs to be able to reward even the smallest of moves towards the goal. 

\subsection*{Why is this problem significant?}

--- most obviously, can be applied to new, less well understood problem domain if we know what approaches are suited to domain independent solutions
--- learn how to take advantage of the strengths of evolved algorithms rather than trying to make them more human

Much research has been done on the application of natural computing methods to games such as Ms PacMan, but why? In many cases (cite 1,2,3) the solutions generated by the algorithms are not particularly successful against hand-crafted solutions explicitly tailored to the problem at hand. Cite 1 says something about this topic.  For example, in grammatical evolution, a grammar is developed, including a long list (cite 2) of the smaller problems within Ms PacMan, and algorithms to solve these smaller problems are hard-coded into the grammar (or in the case of genetic programming, the terminal* set), then the evolution begins.  Much programming time is devoted to, firstly, working out which of these subproblems are most important to the task, and secondly, hand-coding solutions.

Grammatical evolution does not produce programs that meet any of the traditional 'code quality' recommendations*: for example, readability, maintainability, extensibility, or security*. Much like the human genome, programs can contain unused, repeated or unnecessary code, which in a hand-crafted program would be eliminated. Neural networks has a related problem which I describe in this sentence. It is obvious that neither method is designed to produce solutions which are to be kept long-term: they are throwaway solutions, designed to be used for the immediate problem but not examined, modified or extended later.

Another related, often-cited (cite 4,5) reason for applying natural computing methods to well-understood problems such as Ms PacMan is to see if novel solutions are generated. Once the principle of the new solution is understood, it can then be applied to The more domain knowledge is known* from the beginning to the algorithm, however, the closer the final solution is likely to be to a hand-crafted one. 

Given the initial outlay of programmer time and computational effort*, extra computational time involved in evolving the actual program after the initial setup is complete, the 

\subsection*{How will the question be addressed?}

- experimental method



- timeline

week 6: further reading particularly on neural networks
week 7: write interfaces to games
week 8: 
week 9: simulations
week 10: simulations
week 11: write report
week 12: due thursday, so final touches on report
\end{document}
